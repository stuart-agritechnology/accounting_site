// Prisma schema for the Workforce / Payroll / Scheduling platform
//
// Multi-tenant model:
// - Everything hangs off Company.
// - Users can belong to multiple companies via Membership.
// - Authorization is enforced using Membership.roleTier (1..4).
//
// Role tiers (suggested):
// 1 = Worker
// 2 = Supervisor
// 3 = Manager
// 4 = Admin/Owner

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum LeaveType {
  ANNUAL
  PERSONAL
  CARERS
  COMPASSIONATE
  LONG_SERVICE
  UNPAID
  OTHER
}

enum LeaveStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

enum TimeEntryStatus {
  DRAFT
  SUBMITTED
  APPROVED
  REJECTED
}

model Company {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships Membership[]
  customers   Customer[]
  sites       Site[]
  projects    Project[]
  tasks       Task[]
  shifts      Shift[]
  timeEntries TimeEntry[]
  leaves      LeaveRequest[]

  @@index([name])
}

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String?
  image        String?
  passwordHash String? // for Credentials auth
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  memberships Membership[]

  // ✅ distinguish "submitted by user" vs "approved by user"
  timeEntries         TimeEntry[] @relation("TimeEntry_User")
  approvedTimeEntries TimeEntry[] @relation("TimeEntry_ApprovedBy")

  // ✅ distinguish "requested by user" vs "reviewed by user"
  leaveRequests         LeaveRequest[] @relation("LeaveRequest_User")
  reviewedLeaveRequests LeaveRequest[] @relation("LeaveRequest_ReviewedBy")

  // next-auth models
  accounts Account[]
  sessions Session[]

  tasksAssigned    Task[]
  shiftAssignments ShiftAssignment[]

  @@index([email])
}

model Membership {
  id        String   @id @default(cuid())
  companyId String
  userId    String
  roleTier  Int      @default(1)
  title     String? // optional role label for the company
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([companyId, userId])
  @@index([companyId])
  @@index([userId])
}

model Customer {
  id        String   @id @default(cuid())
  companyId String
  name      String
  email     String?
  phone     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company  Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  projects Project[]

  @@index([companyId])
  @@index([name])
}

model Site {
  id          String   @id @default(cuid())
  companyId   String
  name        String
  addressLine String?
  suburb      String?
  state       String?
  postcode    String?
  lat         Float?
  lng         Float?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  company     Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  projects    Project[]
  shifts      Shift[]
  timeEntries TimeEntry[]

  @@index([companyId])
  @@index([name])
}

model Project {
  id         String   @id @default(cuid())
  companyId  String
  customerId String?
  siteId     String?
  code       String?
  name       String
  status     String   @default("ACTIVE")
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  company  Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  customer Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)
  site     Site?     @relation(fields: [siteId], references: [id], onDelete: SetNull)

  tasks       Task[]
  shifts      Shift[]
  timeEntries TimeEntry[]

  @@index([companyId])
  @@index([customerId])
  @@index([siteId])
}

model Task {
  id           String    @id @default(cuid())
  companyId    String
  projectId    String?
  title        String
  description  String?
  assignedToId String?
  dueAt        DateTime?
  status       String    @default("OPEN")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  company    Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  project    Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  assignedTo User?    @relation(fields: [assignedToId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([projectId])
  @@index([assignedToId])
}

model Shift {
  id        String   @id @default(cuid())
  companyId String
  projectId String?
  siteId    String?
  startAt   DateTime
  endAt     DateTime
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  company Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  project Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  site    Site?    @relation(fields: [siteId], references: [id], onDelete: SetNull)

  assignments ShiftAssignment[]

  @@index([companyId])
  @@index([startAt])
}

model ShiftAssignment {
  id        String   @id @default(cuid())
  shiftId   String
  userId    String
  createdAt DateTime @default(now())

  shift Shift @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([shiftId, userId])
  @@index([userId])
}

model TimeEntry {
  id           String          @id @default(cuid())
  companyId    String
  userId       String
  projectId    String?
  siteId       String?
  date         DateTime
  startAt      DateTime?
  endAt        DateTime?
  minutes      Int             @default(0)
  note         String?
  status       TimeEntryStatus @default(DRAFT)
  approvedById String?
  approvedAt   DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // ✅ explicit relation names (fix ambiguous User relation)
  user       User  @relation("TimeEntry_User", fields: [userId], references: [id], onDelete: Cascade)
  approvedBy User? @relation("TimeEntry_ApprovedBy", fields: [approvedById], references: [id], onDelete: SetNull)

  project Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)
  site    Site?    @relation(fields: [siteId], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([userId])
  @@index([date])
}

model LeaveRequest {
  id           String      @id @default(cuid())
  companyId    String
  userId       String
  type         LeaveType   @default(ANNUAL)
  startDate    DateTime
  endDate      DateTime
  minutes      Int         @default(0)
  note         String?
  status       LeaveStatus @default(PENDING)
  reviewedById String?
  reviewedAt   DateTime?
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  // ✅ explicit relation names (fix ambiguous User relation)
  user       User  @relation("LeaveRequest_User", fields: [userId], references: [id], onDelete: Cascade)
  reviewedBy User? @relation("LeaveRequest_ReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)

  @@index([companyId])
  @@index([userId])
  @@index([startDate])
}

// NextAuth models (Prisma Adapter)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
